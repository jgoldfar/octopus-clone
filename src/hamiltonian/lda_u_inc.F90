!! Copyright (C) 2016 N. Tancogne-Dejean 
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
!! 02110-1301, USA.
!!
!! $Id$


subroutine X(lda_u_apply)(this, mesh, d, ik, psib, hpsib, has_phase)
  type(lda_u_t),      intent(in) :: this
  type(mesh_t),       intent(in) :: mesh
  integer,            intent(in) :: ik
  type(batch_t),      intent(in) :: psib
  type(batch_t),   intent(inout) :: hpsib
  type(states_dim_t), intent(in) :: d
  logical,            intent(in) :: has_phase !True if the wavefunction has an associated phase

  integer :: ibatch, idim, ia, imp, im, ispin
  integer :: bind, is
  R_TYPE  :: weight, reduced
  R_TYPE, allocatable :: psi(:,:), hpsi(:,:)
  R_TYPE, allocatable :: dot(:), epsi(:,:)

  PUSH_SUB(lda_u_apply)

  SAFE_ALLOCATE(psi(1:mesh%np, 1:d%dim))
  SAFE_ALLOCATE(epsi(1:this%max_np, 1:d%dim))
  SAFE_ALLOCATE(hpsi(1:mesh%np, 1:d%dim))
  SAFE_ALLOCATE(dot(1:this%maxnorbs))

  ispin = states_dim_get_spin_index(d, ik)

  do ibatch = 1, psib%nst
    call batch_get_state(psib, ibatch, mesh%np, psi)
    call batch_get_state(hpsib,ibatch, mesh%np, hpsi)

    do ia = 1, this%natoms
      ! We have to compute 
      ! hpsi> += sum_m |phi m> sum_m' Vmm' <phi m' | psi >
      !
      ! We first compute <phi m | psi> for all orbitals of the atom
      !
      do im = 1, this%norbs(ia)
        !If we need to add the phase, we explicitly do the operation using the sphere
        !This does not change anything if the sphere occupies the full mesh or not
        if(has_phase) then
          do idim = 1, d%dim
            do is = 1, this%orbitals(im,ia)%sphere%np
              epsi(is,idim) = psi(this%orbitals(im,ia)%sphere%map(is), idim)*&
                              this%orbitals(im,ia)%phase(is, ik) 
            end do
          end do
          dot(im) = X(mf_dotp)(this%orbitals(im,ia)%sphere%mesh,&
                               this%orbitals(im,ia)%X(orbital_sphere),&
                               epsi(1:this%orbitals(im,ia)%sphere%np,1),&
                               np = this%orbitals(im,ia)%sphere%np)
        else
          dot(im) = submesh_to_mesh_dotp(this%orbitals(im,ia)%sphere, 1,  &
                               this%orbitals(im,ia)%X(orbital_sphere),& 
                               psi(1:mesh%np,1:d%dim))
        end if
      end do
      !
      do im = 1, this%norbs(ia)
        ! sum_m' Vmm' <phi m' | psi >
        reduced = M_ZERO
        do imp = 1, this%norbs(ia)
          reduced = reduced + this%X(V)(im,imp,ispin,ia)*dot(imp)
        end do

       !In case of phase, we have to apply the conjugate of the phase here
       if(has_phase) then
         do is = 1, this%orbitals(im,ia)%sphere%np
           epsi(is,1) = this%orbitals(im,ia)%X(orbital_sphere)(is) & 
                          *conjg(this%orbitals(im,ia)%phase(is, ik))
         end do
         do idim = 1, d%dim
          call submesh_add_to_mesh(this%orbitals(im,ia)%sphere, &
                                   epsi(1:this%orbitals(im,ia)%sphere%np,1),&
                                   hpsi(:, idim), reduced)
         end do
       else
         do idim = 1, d%dim
           call submesh_add_to_mesh(this%orbitals(im,ia)%sphere,&
                                   this%orbitals(im,ia)%X(orbital_sphere), &
                                   hpsi(:, idim), reduced)
         end do !idim
       end if
     end do !im
   end do !ia
   call batch_set_state(hpsib, ibatch, mesh%np, hpsi)
  end do !ibatch

  SAFE_DEALLOCATE_A(psi)
  SAFE_DEALLOCATE_A(epsi)
  SAFE_DEALLOCATE_A(hpsi)
  SAFE_DEALLOCATE_A(dot)

  POP_SUB(lda_u_apply)

end subroutine X(lda_u_apply)

! ---------------------------------------------------------
!> This routine compute the values of the occupation matrices
! ---------------------------------------------------------
subroutine X(update_occ_matrices)(this, mesh, st, lda_u_energy, phase)
  type(lda_u_t), intent(inout)         :: this
  type(mesh_t),     intent(in)         :: mesh
  type(states_t),  intent(in)          :: st
  FLOAT, intent(inout)                 :: lda_u_energy
  CMPLX, pointer, optional             :: phase(:,:) 

  integer :: ia, im, ik, ist, ispin, norbs, ip, idim, is
  R_TYPE, allocatable :: psi(:,:), epsi(:)
  R_TYPE, allocatable :: dot(:,:)
  FLOAT   :: weight, renorm_weight
  
  PUSH_SUB(update_occ_matrices)

  this%X(n)(1:this%maxnorbs,1:this%maxnorbs,1:st%d%nspin,1:this%natoms) = R_TOTYPE(M_ZERO)
  SAFE_ALLOCATE(psi(1:mesh%np, 1:st%d%dim))
  SAFE_ALLOCATE(epsi(1:this%max_np))
  SAFE_ALLOCATE(dot(1:this%maxnorbs,1:this%natoms))

  if(this%useACBN0) &
    this%X(n_alt)(1:this%maxnorbs,1:this%maxnorbs,1:st%d%nspin,1:this%natoms) = R_TOTYPE(M_ZERO)

  !TODO: use symmetries of the occupation matrices
  do ik = st%d%kpt%start, st%d%kpt%end
    ispin =  states_dim_get_spin_index(st%d,ik)
    do ist = st%st_start, st%st_end
      
      if(this%useACBN0) then
        this%renorm_occ(:,ist,ik) = M_ZERO
      else
        this%renorm_occ(:,ist,ik) = M_ONE !st%occ(ist, ik)
      end if
      weight = st%d%kweights(ik)*st%occ(ist, ik) 

      call states_get_state(st, mesh, ist, ik, psi )  
      if(present(phase)) then 
        ! Apply the phase that contains both the k-point and vector-potential terms.
        do idim = 1, st%d%dim
          do ip = 1, mesh%np
            psi(ip, idim) = phase(ip, ik)*psi(ip, idim)
          end do
        end do
      end if
      
      do ia = 1, this%natoms
        norbs = this%norbs(ia)
        if(norbs.eq. M_ZERO ) cycle
        !We first compute the matrix elemets <\psi | orb_m>
        !taking into account phase correction if needed 
        do im = 1, norbs
          if(present(phase)) then
            do is = 1, this%orbitals(im,ia)%sphere%np
              epsi(is) = psi(this%orbitals(im,ia)%sphere%map(is), 1)*this%orbitals(im,ia)%phase(is, ik)
            end do
            dot(im,ia) = X(mf_dotp)(this%orbitals(im,ia)%sphere%mesh, &
                                 epsi(1:this%orbitals(im,ia)%sphere%np),& 
                                 this%orbitals(im,ia)%X(orbital_sphere),&
                                 np = this%orbitals(im,ia)%sphere%np )
          else
            dot(im,ia) =  submesh_to_mesh_dotp(this%orbitals(im,ia)%sphere, 1,&
                                               this%orbitals(im,ia)%X(orbital_sphere), &
                                               psi(1:mesh%np,1:st%d%dim))
          end if
         
          !We compute the on-site occupation of the site, if needed
          if(this%useACBN0) then
            this%renorm_occ(this%orbitals(im,ia)%ll,ist,ik) = &
                this%renorm_occ(this%orbitals(im,ia)%ll,ist,ik) + abs(dot(im,ia))**2
          end if
        end do
      end do 
     
      !We can compute the (renormalized) occupation matrices
      do ia = 1, this%natoms
        norbs = this%norbs(ia)
        if(norbs.eq. M_ZERO ) cycle 
        do im = 1, norbs
            this%X(n)(1:norbs,im,ispin,ia) = this%X(n)(1:norbs,im,ispin,ia) &
                                         + weight*dot(1:norbs,ia)*R_CONJ(dot(im,ia))
            !We compute the renomalized occupation matrices
            if(this%useACBN0) then
              renorm_weight = this%renorm_occ(this%orbitals(im,ia)%ll,ist,ik)*weight
              this%X(n_alt)(1:norbs,im,ispin,ia) = this%X(n_alt)(1:norbs,im,ispin,ia) &
                                         + renorm_weight*dot(1:norbs,ia)*R_CONJ(dot(im,ia))
            end if 
        end do
       !  call lalg_her( norbs, weight, this%X(n)(1:norbs,1:norbs,ispin,ia), dot)
      end do
    end do
  end do

  
  SAFE_DEALLOCATE_A(dot)
  SAFE_DEALLOCATE_A(epsi)
  SAFE_DEALLOCATE_A(psi)

#if defined(HAVE_MPI)        
  if(st%parallel_in_states .or. st%d%kpt%parallel) then
    call comm_allreduce(st%st_kpt_mpi_grp%comm, this%X(n))
    if(this%useACBN0) &
      call comm_allreduce(st%st_kpt_mpi_grp%comm, this%X(n_alt))
  end if
#endif      

  call X(compute_dudarev_energy)(this, st, lda_u_energy)
  call X(update_potential_lda_u)(this,  st)

  POP_SUB(update_occ_matrices)
end subroutine X(update_occ_matrices)

! ---------------------------------------------------------
!> This routine compute the value of the double counting term in the LDA+U energy
! ---------------------------------------------------------
subroutine X(compute_dudarev_energy)(this, st, lda_u_energy)
  type(lda_u_t), intent(inout)    :: this
  type(states_t),  intent(in)     :: st
  FLOAT, intent(inout)            :: lda_u_energy
 
  integer :: ia, imp, im, ispin

  PUSH_SUB(compute_dudarev_energy)

  lda_u_energy = M_ZERO

  do ia = 1, this%natoms
    do ispin = 1, st%d%nspin
      !TODO: These are matrix operations, that could be optimized
      do im = 1, this%norbs(ia)
        do imp = 1, this%norbs(ia)
          lda_u_energy = lda_u_energy - CNST(0.5)*this%Ueff(ia)*abs(this%X(n)(im,imp,ispin,ia))**2
        end do
        lda_u_energy = lda_u_energy + CNST(0.5)*this%Ueff(ia)*this%X(n)(im,im,ispin,ia)
      end do
    end do
  end do

  POP_SUB(compute_dudarev_energy)
end subroutine X(compute_dudarev_energy)


! ---------------------------------------------------------
!> This routine compute the potential that, once multiplied
!> by the projector Pmm' and summed over m and m' for all the atoms
!> gives the full Hubbard potential
! ---------------------------------------------------------
subroutine X(update_potential_lda_u)(this, st)
  type(lda_u_t), intent(inout)    :: this
  type(states_t),  intent(in)     :: st

  integer :: ia, im, ispin, norbs

  PUSH_SUB(update_potential_lda_u)

  do ia = 1, this%natoms
    norbs = this%norbs(ia)
    do ispin = 1, st%d%nspin
      do im = 1, norbs
        this%X(V)(1:norbs,im,ispin,ia) = - this%Ueff(ia)*this%X(n)(1:norbs,im,ispin,ia)
        this%X(V)(im,im,ispin,ia) = this%X(V)(im,im,ispin,ia) + CNST(0.5)*this%Ueff(ia)
      end do
    end do
  end do

  POP_SUB(update_potential_lda_u)
end subroutine X(update_potential_lda_u)


! ---------------------------------------------------------
!> This routine compute the effective U following the expression 
!> given in Agapito et al., Phys. Rev. X 5, 011006 (2015)
! ---------------------------------------------------------
subroutine X(compute_ACBNO_U)(this, st)
  type(lda_u_t), intent(inout)    :: this
  type(states_t),  intent(in)     :: st
  
  integer :: ia, im, imp, impp, imppp, ispin1, ispin2, norbs
  FLOAT   :: numU, numJ, denomU, denomJ, tmpU, tmpJ

  PUSH_SUB(compute_ACBNO_U)

  do ia = 1, this%natoms
    norbs = this%norbs(ia)
    if(norbs.eq. M_ZERO ) cycle 
    numU = M_ZERO
    numJ = M_ZERO
    denomU = M_ZERO
    denomJ = M_ZERO

    do im = 1, norbs
    do imp = 1,norbs
      do impp = 1, norbs
      do imppp = 1, norbs
        ! We first compute the terms
        ! sum_{alpha,beta} P^alpha_{mmp}P^beta_{mpp,mppp}  
        ! sum_{alpha} P^alpha_{mmp}P^alpha_{mpp,mppp}
        tmpU = M_ZERO
        tmpJ = M_ZERO
        do ispin1 = 1, st%d%nspin
          do ispin2 = 1, st%d%nspin
            tmpU = tmpU + this%X(n_alt)(im,imp,ispin1,ia)*this%X(n_alt)(impp,imppp,ispin2,ia)
          end do
          tmpJ = tmpJ + this%X(n_alt)(im,imp,ispin1,ia)*this%X(n_alt)(impp,imppp,ispin1,ia)
        end do
        ! These are the numerator of the ACBN0 U and J
        numU = numU + tmpU*this%coulomb(im,imp,impp,imppp,ia)
        numJ = numJ + tmpJ*this%coulomb(im,imppp,impp,imp,ia) 
      end do
      end do

      ! We compute the term
      ! sum_{alpha} sum_{m,mp/=m} N^alpha_{m}N^alpha_{mp}
      tmpJ = M_ZERO
      if(imp/=im) then
        do ispin1 = 1, st%d%nspin
          tmpJ = tmpJ + this%X(n)(im,im,ispin1,ia)*this%X(n)(imp,imp,ispin1,ia)
        end do
      end if
      denomJ = denomJ + tmpJ
      denomU = denomU + tmpJ

      ! We compute the term
      ! sum_{alpha,beta} sum_{m,mp} N^alpha_{m}N^beta_{mp}
      tmpU = M_ZERO
      do ispin1 = 1, st%d%nspin
        do ispin2 = 1, st%d%nspin
          if(ispin1 /= ispin2) then
            tmpU = tmpU + this%X(n)(im,im,ispin1,ia)*this%X(n)(imp,imp,ispin2,ia)
          end if
        end do
      end do
      denomU = denomU + tmpU

    end do
    end do

    this%Ueff(ia) = numU/denomU - numJ/denomJ

  end do

  POP_SUB(compute_ACBNO_U)  
end subroutine X(compute_ACBNO_U)

! ---------------------------------------------------------
! TODO: Merge this with the two_body routine in system/output_me_inc.F90
subroutine X(compute_coulomb_integrals) (this, mesh, st)
  type(lda_u_t), intent(inout)  :: this
  type(mesh_t),     intent(in)  :: mesh
  type(states_t),   intent(in)  :: st

  integer :: ist, jst, kst, lst, ijst, klst
  integer :: norbs, np_sphere, ia, ip
  FLOAT, allocatable :: tmp(:), vv(:), nn_sphere(:)
  type(orbital_t), pointer :: orbi, orbj, orbk, orbl

  PUSH_SUB(X(compute_coulomb_integrals))

  ASSERT(.not. st%parallel_in_states)
  
  SAFE_ALLOCATE(nn_sphere(1:this%max_np))
  SAFE_ALLOCATE(vv(1:this%max_np))
  SAFE_ALLOCATE(tmp(1:this%max_np))

  do ia = 1, this%natoms
    norbs = this%norbs(ia)
    if(norbs.eq. M_ZERO ) cycle
   
    ijst=0
    do ist = 1, norbs
      orbi => this%orbitals(ist,ia) 
      np_sphere = orbi%sphere%np
      
      do jst = 1, norbs
        if(jst > ist) cycle
        ijst=ijst+1
        orbj => this%orbitals(jst,ia)

        nn_sphere(1:np_sphere)  = real(orbi%X(orbital_sphere)(1:np_sphere)) &
                          *real(orbj%X(orbital_sphere)(1:np_sphere))
        !Here it is important to use a non-periodic poisson solver, e.g. the direct solver
        call dpoisson_solve_sm(psolver, orbi%sphere, vv(1:np_sphere), nn_sphere(1:np_sphere), all_nodes=.true.)

        klst=0
        do kst = 1, norbs
          orbk => this%orbitals(kst,ia)
          do lst = 1, norbs
            if(lst > kst) cycle
            klst=klst+1
           if(klst > ijst) cycle

            orbl => this%orbitals(lst,ia)

            do ip=1,np_sphere
             tmp(ip) = vv(ip)*real(orbl%X(orbital_sphere)(ip)) &
                             *real(orbk%X(orbital_sphere)(ip))
            end do
            this%coulomb(ist,jst,kst,lst,ia) = dsm_integrate(mesh, orbl%sphere, tmp(1:np_sphere))

            if(abs(this%coulomb(ist,jst,kst,lst,ia))<CNST(1.0e-12)) then
              this%coulomb(ist,jst,kst,lst,ia) = M_ZERO
            else
              this%coulomb(kst,lst,ist,jst,ia) = this%coulomb(ist,jst,kst,lst,ia)              
              this%coulomb(jst,ist,lst,kst,ia) = this%coulomb(ist,jst,kst,lst,ia)
              this%coulomb(lst,kst,jst,ist,ia) = this%coulomb(ist,jst,kst,lst,ia)
              this%coulomb(jst,ist,kst,lst,ia) = this%coulomb(ist,jst,kst,lst,ia)
              this%coulomb(lst,kst,ist,jst,ia) = this%coulomb(ist,jst,kst,lst,ia)              
              this%coulomb(ist,jst,lst,kst,ia) = this%coulomb(ist,jst,kst,lst,ia)
              this%coulomb(kst,lst,jst,ist,ia) = this%coulomb(ist,jst,kst,lst,ia)              
            end if
          end do !lst
        end do !kst
      end do !jst
    end do !ist
  end do !ia
 
  SAFE_DEALLOCATE_A(nn_sphere)
  SAFE_DEALLOCATE_A(vv)
  SAFE_DEALLOCATE_A(tmp)

  POP_SUB(X(compute_coulomb_integrals))
end subroutine X(compute_coulomb_integrals)

! ---------------------------------------------------------
!> This routine computes [r,V_lda+u].
! ---------------------------------------------------------
!subroutine X(lda_u_commute_r)(this, mesh, ik, psi, gpsi)
!   type(scissor_t), intent(in)    :: this
!   type(mesh_t),    intent(in)    :: mesh 
!   R_TYPE,          intent(in)    :: psi(:,:)
!   integer,         intent(in)    :: ik
!   R_TYPE,          intent(inout) :: gpsi(:, :, :)
!
!   integer :: ist, idim, idir
!   R_TYPE  :: dot
!   R_TYPE, allocatable :: gspsi(:,:), tmpstate(:,:), psi_r(:)
!
!   PUSH_SUB(lda_u_commute_r)
!
!   SAFE_ALLOCATE(gspsi(1:mesh%np, 1:this%gs_st%d%dim))
!   SAFE_ALLOCATE(psi_r(1:mesh%np))
!   SAFE_ALLOCATE(tmpstate(1:mesh%np, 1:this%gs_st%d%dim))
!   
!   tmpstate(1:mesh%np, 1:this%gs_st%d%dim) = R_TOTYPE(M_ZERO)
!   do ia = 1, geo%natoms
!     do imp = 1, this%maxorb(ia)
!       dot = X(mf_dotp)(mesh, this%X(basis)(1:mesh%np,imp,ispin,ia),psi(1:mesh%np,idim))
!       do im = 1, this%maxorb(ia)
!          call lalg_axpy(mesh%np, -this%X(V)(im,imp,ispin,ia)*dot, &
!                 this%X(basis)(1:mesh%np,im,ispin,ia), hpsi(1:mesh%np, idim))
!         
!   do ist = 1, this%gs_st%nsti
!     call states_get_state(this%gs_st, mesh, ist, ik, gspsi )
!     !<gpsi|psi>
!     dot = X(mf_dotp)(mesh, this%gs_st%d%dim, gspsi(1:mesh%np,1:this%gs_st%d%dim), psi) &
!           * this%gs_st%occ(ist, ik)/ this%gs_st%smear%el_per_state
!     do idim = 1, this%gs_st%d%dim
!      call lalg_axpy(mesh%np, dot,  gspsi(1:mesh%np, idim), tmpstate(1:mesh%np, idim)) 
!     enddo
!   enddo
!   ! |gpsi> -= x|phim><phim'|psi>
!   do idim = 1, this%gs_st%d%dim
!     do idir = 1, mesh%sb%dim
!       gpsi(1:mesh%np, idir, idim) = gpsi(1:mesh%np, idir, idim) &
!             -  mesh%x(1:mesh%np, idir) * tmpstate(1:mesh%np, idim)
!     enddo
!   enddo
!
!   do idim = 1, this%gs_st%d%dim
!     do idir = 1, mesh%sb%dim
!  
!       psi_r(1:mesh%np) = mesh%x(1:mesh%np,idir) * psi(1:mesh%np, idim)
!
!       tmpstate(1:mesh%np,idim) = R_TOTYPE(M_ZERO)
!       do ist = 1, this%gs_st%nst
!         call states_get_state(this%gs_st, mesh, ist, ik, gspsi )
!         ! <gspsi|r|psi>
!         dot = X(mf_dotp)(mesh, gspsi(1:mesh%np,idim), psi_r(1:mesh%np)) &
!           * this%gs_st%occ(ist, ik) / this%gs_st%smear%el_per_state
!         call lalg_axpy(mesh%np, dot,  gspsi(1:mesh%np, idim), tmpstate(1:mesh%np, idim))
!       enddo
!       ! |gpsi> +=  |gspsi><gspsi|x|psi>
!       gpsi(1:mesh%np, idir, idim) = gpsi(1:mesh%np, idir, idim) &
!             +  tmpstate(1:mesh%np, idim)
!     enddo
!   enddo
!
!   SAFE_DEALLOCATE_A(gspsi)
!   SAFE_DEALLOCATE_A(psi_r)
!   SAFE_DEALLOCATE_A(tmpstate) 
!
!   POP_SUB(lda_u_commute_r)
!end subroutine X(lda_u_commute_r)

! ---------------------------------------------------------
!> This routine is an interface for constructing the orbital basis.
! ---------------------------------------------------------
subroutine X(construct_orbital_basis)(this, geo, mesh, st)
  type(lda_u_t),             intent(inout)    :: this
  type(geometry_t), target,  intent(in)       :: geo
  type(mesh_t),              intent(in)       :: mesh
  type(states_t),            intent(in)       :: st 

  integer :: ia, iorb, norb, ispin
  integer ::  hubbardl, ii, ll, mm
  FLOAT   :: norm


  PUSH_SUB(X(construct_orbital_basis))

  write(message(1),'(a)')    'Building the LDA+U localized orbital basis.'
  call messages_info(1)

  !We first find the number of orbitals for each atoms
  SAFE_ALLOCATE(this%norbs(1:geo%natoms))
  this%norbs = 0
  do ia = 1, geo%natoms
    hubbardl = species_hubbard_l(geo%atom(ia)%species)
    if( hubbardl .eq. 0 ) cycle
    this%norbs(ia) = 0
    do iorb = 1, species_niwfs(geo%atom(ia)%species)
      call species_iwf_ilm(geo%atom(ia)%species, iorb, 1, ii, ll, mm)
      if(ll .eq. hubbardl ) this%norbs(ia) = this%norbs(ia) + 1
    end do !iorb
  end do  !ia
  this%maxnorbs = maxval(this%norbs) 
  
  do ia = 1, geo%natoms
    write(message(1),'(a,i2,a,f8.5,a)')    'Atom ', ia, ' has a value of U of ',&
                            species_hubbard_u(geo%atom(ia)%species), ' Ha.'
    call messages_info(1)

    write(message(1),'(a,i2,a, i3)')    'Found ', this%norbs(ia), ' orbitals for atom ', ia
     call messages_info(1)
  end do
 
  SAFE_ALLOCATE(this%orbitals(1:this%maxnorbs, 1:geo%natoms))
  SAFE_ALLOCATE(this%Ueff(1:geo%natoms))
  this%Ueff(1:geo%natoms) = M_ZERO

  do ia = 1, geo%natoms
    hubbardl = species_hubbard_l(geo%atom(ia)%species)
    this%Ueff(ia) = species_hubbard_u(geo%atom(ia)%species)
    if( hubbardl .eq. M_ZERO ) cycle
 
    norb = 0
    do iorb = 1, species_niwfs(geo%atom(ia)%species)
      call species_iwf_ilm(geo%atom(ia)%species, iorb, 1, ii, ll, mm)
      if(ll .eq. hubbardl ) then 
        norb = norb + 1
        ! We obtain the orbital
        call X(get_atomic_orbital)(geo, mesh, ia, iorb, 1, this%orbitals(norb,ia), this%truncation, this%orbitals_threshold) 
        ! We have to normalize the orbitals, 
        ! in case the orbitals that comes out of the pseudo are not properly normalised
        norm = X(sm_nrm2)(this%orbitals(norb,ia)%sphere, this%orbitals(norb,ia)%X(orbital_sphere)(1:this%orbitals(norb,ia)%sphere%np))
        this%orbitals(norb,ia)%X(orbital_sphere)(1:this%orbitals(norb,ia)%sphere%np) =  &
                this%orbitals(norb,ia)%X(orbital_sphere)(1:this%orbitals(norb,ia)%sphere%np) /sqrt(norm)

        ! In case of complex wavefunction, we allocate the array for the phase correction
  #ifdef R_TCOMPLEX
        SAFE_ALLOCATE(this%orbitals(norb,ia)%phase(1:this%orbitals(norb,ia)%sphere%np, st%d%kpt%start:st%d%kpt%end))
        this%orbitals(norb,ia)%phase(:,:) = M_ZERO
  #endif
        ! We store the angular momentum of the orbital
        this%orbitals(norb,ia)%ll = ll

        ! We need to know the maximum number of points in order to allocate a temporary array
        ! to apply the phase in lda_u_apply
        if(this%orbitals(norb,ia)%sphere%np > this%max_np) &
          this%max_np = this%orbitals(norb,ia)%sphere%np
      endif
    end do
  end do

  POP_SUB(X(construct_orbital_basis))

end subroutine X(construct_orbital_basis)


! ---------------------------------------------------------
!> This routine returns the atomic orbital basis -- provided
!! by the pseudopotential structure in geo.
! ---------------------------------------------------------
subroutine X(get_atomic_orbital) (geo, mesh, iatom, iorb, ispin, orb, truncation, threshold)
  type(mesh_t),             intent(in)    :: mesh
  type(geometry_t), target, intent(in)    :: geo
  integer,                  intent(in)    :: iatom
  integer,                  intent(in)    :: iorb
  integer,                  intent(in)    :: ispin
  type(orbital_t),          intent(inout) :: orb
  integer,                  intent(in)    :: truncation
  FLOAT,                    intent(in)    :: threshold

  type(species_t), pointer :: spec
  integer :: ii, ll, mm, ispin_
  FLOAT :: radius
  logical :: complex_ylms

  PUSH_SUB(X(get_atomic_orbital))

  ispin_ = ispin 

  spec => geo%atom(iatom)%species
  ASSERT(iorb <= species_niwfs(spec))

  nullify(orb%dorbital_sphere)
  nullify(orb%zorbital_sphere)
  nullify(orb%phase)

  call species_iwf_ilm(spec, iorb, ispin_, ii, ll, mm)

  if(truncation == OPTION__ORBITALSTRUNCATIONMETHOD__FULL) then
    radius = species_get_iwf_radius(spec, ii, ispin_, threshold) 
  else
    radius = species_get_iwf_radius(spec, ii, ispin_)
   
    if(truncation == OPTION__ORBITALSTRUNCATIONMETHOD__BOX) then
      ! if the orbital is larger than the size of the box, we restrict it to this size, 
      ! otherwise the orbital will overlap more than one time with the simulation box.
      ! This would induces phase problem if the complete mesh is used instead of the sphere
      radius = min(radius, minval(mesh%sb%lsize(1:mesh%sb%dim)-mesh%spacing(1:mesh%sb%dim)*CNST(1.01)))
    else
      !If asked, we truncate the orbital to the radius on the projector spheres 
      !of the NL part of the pseudopotential.
      !This is a way to garanty no overlap between orbitals of different atoms.
      if(species_is_ps(spec)) &
        radius = min(radius,species_get_ps_radius(spec))
    end if
  end if
  ! make sure that if the spacing is too large, the orbitals fit in a few points at least
  radius = max(radius, CNST(2.0)*maxval(mesh%spacing(1:mesh%sb%dim)))
 
  !We initialise the submesh corresponding to the orbital 
  call submesh_init(orb%sphere, mesh%sb, mesh, geo%atom(iatom)%x, radius)
  if(radius >= minval(mesh%sb%lsize(1:mesh%sb%dim)-mesh%spacing(1:mesh%sb%dim))) then
    write(message(1),'(a,i5,a)')  'This is an extended orbital, with ', orb%sphere%np, ' grid points.'
    write(message(2),'(a,f8.5,a)') 'The radius is ', radius, ' Bohr.'
    call messages_info(2)
  end if

  !We allocate both the orbital on the submesh and on the complete mesh
  SAFE_ALLOCATE(orb%X(orbital_sphere)(1:orb%sphere%np))
  orb%X(orbital_sphere) = M_ZERO

  !This is a bit dirty.
  complex_ylms = .false.

  !We get the orbital from the pseudopotential
  #ifdef R_TCOMPLEX
  if(.not. complex_ylms) then
    !In this case we want to get a real orbital and to store it in complex array
    SAFE_ALLOCATE(orb%dorbital_sphere(1:orb%sphere%np))
    call dspecies_get_orbital_submesh(spec, orb%sphere, ii, ll, mm, ispin_, geo%atom(iatom)%x, &
                                            orb%dorbital_sphere)
    orb%X(orbital_sphere)(1:orb%sphere%np) = orb%dorbital_sphere(1:orb%sphere%np)
    SAFE_DEALLOCATE_P(orb%dorbital_sphere)
  else
  #endif
    call X(species_get_orbital_submesh)(spec, orb%sphere, ii, ll, mm, ispin_, geo%atom(iatom)%x,&
                                         orb%X(orbital_sphere))
  #ifdef R_TCOMPLEX
  end if
  #endif

  POP_SUB(X(get_atomic_orbital))

end subroutine X(get_atomic_orbital)

! ---------------------------------------------------------

