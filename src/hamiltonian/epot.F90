!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
!! 02110-1301, USA.
!!

#include "global.h"

module epot_oct_m
  use atom_oct_m
  use comm_oct_m
  use derivatives_oct_m
  use double_grid_oct_m
  use gauge_field_oct_m
  use geometry_oct_m
  use global_oct_m
  use grid_oct_m
  use index_oct_m
  use io_oct_m
  use ion_interaction_oct_m
  use kick_oct_m
  use lalg_adv_oct_m
  use lalg_basic_oct_m
  use loct_math_oct_m
  use logrid_oct_m
  use mesh_oct_m
  use mesh_function_oct_m
  use messages_oct_m
  use mpi_oct_m
  use parser_oct_m
  use periodic_copy_oct_m
  use poisson_oct_m
  use poisson_cutoff_oct_m
  use profiling_oct_m
  use projector_oct_m
  use ps_oct_m
  use simul_box_oct_m
  use species_oct_m
  use species_pot_oct_m
  use splines_oct_m
  use spline_filter_oct_m
  use states_oct_m
  use states_dim_oct_m
  use submesh_oct_m
  use symmetrizer_oct_m
  use unit_oct_m
  use unit_system_oct_m
  use varinfo_oct_m
  use xc_oct_m

  implicit none

  private
  public ::                        &
    epot_t,                        &
    epot_init,                     &
    epot_end,                      &
    epot_generate,                 &
    epot_local_potential
  
  type epot_t
    ! Ions
    FLOAT,             pointer :: vpsl(:)       !< the local part of the pseudopotentials
                                                !< plus the potential from static electric fields
    type(projector_t), pointer :: proj(:)       !< non-local projectors
    logical                    :: non_local
    integer                    :: natoms
    ! External e-m fields
    FLOAT,         pointer :: E_field(:)           !< static electric field
    FLOAT, pointer         :: v_static(:)          !< static scalar potential
    FLOAT, allocatable     :: v_ext(:)             !< static scalar potential - 1:gr%mesh%np_part
    type(gauge_field_t)    :: gfield               !< the time-dependent gauge field
    !> The possible kick
    type(kick_t) :: kick
    !> the ion-ion energy and force
    FLOAT          :: eii
    FLOAT, pointer :: fii(:, :)
    real(4), pointer :: local_potential(:,:)
    logical                  :: have_density
    type(poisson_t), pointer :: poisson_solver
    logical :: force_total_enforce
    type(ion_interaction_t) :: ion_interaction
  end type epot_t

contains

  subroutine epot_init( ep, gr, geo, ispin, nik, xc_family)
    type(epot_t),                       intent(out)   :: ep
    type(grid_t),                       intent(in)    :: gr
    type(geometry_t),                   intent(inout) :: geo
    integer,                            intent(in)    :: ispin
    integer,                            intent(in)    :: nik
    integer,                            intent(in)    :: xc_family

    integer :: ispec, ip, idir, ia, gauge_2d, ierr
    type(block_t) :: blk
    FLOAT, allocatable :: grx(:)
    integer :: filter
    character(len=100)  :: function_name

    PUSH_SUB(epot_init)

    !%Variable FilterPotentials
    !%Type integer
    !%Default filter_ts
    !%Section Hamiltonian
    !%Description
    !% <tt>Octopus</tt> can filter the pseudopotentials so that they no
    !% longer contain Fourier components larger than the mesh itself. This is
    !% very useful to decrease the egg-box effect, and so should be used in
    !% all instances where atoms move (<i>e.g.</i> geometry optimization,
    !% molecular dynamics, and vibrational modes).
    !%Option filter_none 0
    !% Do not filter.
    !%Option filter_TS 2
    !% The filter of M. Tafipolsky and R. Schmid, <i>J. Chem. Phys.</i> <b>124</b>, 174102 (2006).
    !%Option filter_BSB 3
    !% The filter of E. L. Briggs, D. J. Sullivan, and J. Bernholc, <i>Phys. Rev. B</i> <b>54</b>, 14362 (1996).
    !%End
    call parse_variable('FilterPotentials', PS_FILTER_TS, filter)
    if(.not.varinfo_valid_option('FilterPotentials', filter)) call messages_input_error('FilterPotentials')
    call messages_print_var_option(stdout, "FilterPotentials", filter)

    if(filter == PS_FILTER_TS) call spline_filter_mask_init()
    do ispec = 1, geo%nspecies
      call species_pot_init(geo%species(ispec), mesh_gcutoff(gr%mesh), filter)
    end do

    SAFE_ALLOCATE(ep%vpsl(1:gr%mesh%np))
    ep%vpsl(1:gr%mesh%np) = M_ZERO
    call kick_init(ep%kick, ispin, gr%mesh%sb%dim, gr%mesh%sb%periodic_dim)

    ! No more "UserDefinedTDPotential" from this version on.
    call messages_obsolete_variable('UserDefinedTDPotential', 'TDExternalFields')

    !%Variable StaticElectricField
    !%Type block
    !%Default 0
    !%Section Hamiltonian
    !%Description
    !% A static constant electric field may be added to the usual Hamiltonian,
    !% by setting the block <tt>StaticElectricField</tt>.
    !% The three possible components of the block (which should only have one
    !% line) are the three components of the electric field vector.
    !%End
    nullify(ep%E_field, ep%v_static)
    if(parse_block('StaticElectricField', blk)==0) then
      SAFE_ALLOCATE(ep%E_field(1:gr%sb%dim))
      do idir = 1, gr%sb%dim
        call parse_block_float(blk, 0, idir - 1, ep%E_field(idir), units_inp%energy / units_inp%length)

        if(idir <= gr%sb%periodic_dim .and. abs(ep%E_field(idir)) > M_EPSILON) then
          call messages_write("Cannot apply an electric field in a periodic system.")
          call messages_fatal()
        end if
      end do
      call parse_block_end(blk)

      if(gr%sb%periodic_dim < gr%sb%dim) then
        ! Compute the scalar potential
        !
        ! Note that the -1 sign is missing. This is because we
        ! consider the electrons with +1 charge. The electric field
        ! however retains the sign because we also consider protons to
        ! have +1 charge when calculating the force.
        SAFE_ALLOCATE(ep%v_static(1:gr%mesh%np))
        forall(ip = 1:gr%mesh%np)
          ep%v_static(ip) = sum(gr%mesh%x(ip, gr%sb%periodic_dim + 1:gr%sb%dim) * ep%E_field(gr%sb%periodic_dim + 1:gr%sb%dim))
        end forall
        ! The following is needed to make interpolations.
        ! It is used by PCM.
        SAFE_ALLOCATE(ep%v_ext(1:gr%mesh%np_part))
        forall(ip = 1:gr%mesh%np_part)
          ep%v_ext(ip) = sum(gr%mesh%x(ip, gr%sb%periodic_dim + 1:gr%sb%dim) * ep%E_field(gr%sb%periodic_dim + 1:gr%sb%dim))
        end forall
      end if
    end if

    !%Variable ForceTotalEnforce
    !%Type logical
    !%Default no
    !%Section Hamiltonian
    !%Description
    !% (Experimental) If this variable is set to "yes", then the sum
    !% of the total forces will be enforced to be zero.
    !%End
    call parse_variable('ForceTotalEnforce', .false., ep%force_total_enforce)
    if(ep%force_total_enforce) call messages_experimental('ForceTotalEnforce')

    SAFE_ALLOCATE(ep%proj(1:geo%natoms))
    do ia = 1, geo%natoms
      call projector_null(ep%proj(ia))
    end do

    ep%natoms = geo%natoms
    ep%non_local = .false.

    ep%eii = M_ZERO
    SAFE_ALLOCATE(ep%fii(1:gr%sb%dim, 1:geo%natoms))
    ep%fii = M_ZERO

    call gauge_field_nullify(ep%gfield)

    nullify(ep%local_potential)

    ep%have_density = .false.
    do ia = 1, geo%natoms
      if(local_potential_has_density(gr%mesh%sb, geo%atom(ia))) then
        ep%have_density = .true.
        exit
      end if
    end do

    if(ep%have_density) then
      ep%poisson_solver => psolver
    else
      nullify(ep%poisson_solver)
    end if

    call ion_interaction_init(ep%ion_interaction)

    POP_SUB(epot_init)
  end subroutine epot_init

  ! ---------------------------------------------------------
  subroutine epot_end(ep)
    type(epot_t), intent(inout) :: ep

    integer :: iproj

    PUSH_SUB(epot_end)

    call ion_interaction_end(ep%ion_interaction)
    
    if(ep%have_density) then
      nullify(ep%poisson_solver)
    end if

    SAFE_DEALLOCATE_P(ep%local_potential)
    SAFE_DEALLOCATE_P(ep%fii)
    SAFE_DEALLOCATE_P(ep%vpsl)

    call kick_end(ep%kick)

    ! the macroscopic fields
    SAFE_DEALLOCATE_P(ep%E_field)
    SAFE_DEALLOCATE_P(ep%v_static)
    SAFE_DEALLOCATE_A(ep%v_ext)

    do iproj = 1, ep%natoms
      if (projector_is_null(ep%proj(iproj))) cycle
      call projector_end(ep%proj(iproj))
    end do

    ASSERT(associated(ep%proj))
    SAFE_DEALLOCATE_P(ep%proj)

    POP_SUB(epot_end)
  end subroutine epot_end

  ! ---------------------------------------------------------
  subroutine epot_generate(ep, gr, geo, st)
    type(epot_t),             intent(inout) :: ep
    type(grid_t),     target, intent(in)    :: gr
    type(geometry_t), target, intent(in)    :: geo
    type(states_t),           intent(inout) :: st

    integer :: ia, ip
    type(atom_t),      pointer :: atm
    type(mesh_t),      pointer :: mesh
    type(simul_box_t), pointer :: sb
    type(profile_t), save :: epot_generate_prof
    FLOAT,    allocatable :: density(:)
    FLOAT,    allocatable :: tmp(:)
    type(profile_t), save :: epot_reduce
    type(ps_t), pointer :: ps
    type(symmetrizer_t) :: symmetrizer
    FLOAT, allocatable :: tmpdensity(:)
    
    call profiling_in(epot_generate_prof, "EPOT_GENERATE")
    PUSH_SUB(epot_generate)

    sb   => gr%sb
    mesh => gr%mesh

    SAFE_ALLOCATE(density(1:mesh%np))
    density = M_ZERO

    ! Local part
    ep%vpsl = M_ZERO
    if(geo%nlcc) st%rho_core = M_ZERO

    do ia = geo%atoms_dist%start, geo%atoms_dist%end
      if(geo%nlcc) then
        call epot_local_potential(ep, gr%der, gr%dgrid, geo, ia, ep%vpsl, rho_core = st%rho_core, density = density)
      else
        call epot_local_potential(ep, gr%der, gr%dgrid, geo, ia, ep%vpsl, density = density)
      end if
    end do

    ! reduce over atoms if required
    if(geo%atoms_dist%parallel) then
      call profiling_in(epot_reduce, "EPOT_REDUCE")

      call comm_allreduce(geo%atoms_dist%mpi_grp%comm, ep%vpsl, dim = gr%mesh%np)
      if(associated(st%rho_core)) &
        call comm_allreduce(geo%atoms_dist%mpi_grp%comm, st%rho_core, dim = gr%mesh%np)
      if(ep%have_density) &
        call comm_allreduce(geo%atoms_dist%mpi_grp%comm, density, dim = gr%mesh%np)
      call profiling_out(epot_reduce)
    end if

   if(st%symmetrize_density) then
      SAFE_ALLOCATE(tmpdensity(1:gr%mesh%np))
      call symmetrizer_init(symmetrizer, gr%mesh)

      call dsymmetrizer_apply(symmetrizer, gr%mesh%np, field = ep%vpsl, symmfield = tmpdensity)
      ep%vpsl(1:gr%mesh%np) = tmpdensity(1:gr%mesh%np)

      if(associated(st%rho_core)) then
        call dsymmetrizer_apply(symmetrizer, gr%mesh%np, field = st%rho_core, symmfield = tmpdensity)
        st%rho_core(1:gr%mesh%np) = tmpdensity(1:gr%mesh%np)
      end if

      if(ep%have_density) then
        call dsymmetrizer_apply(symmetrizer, gr%mesh%np, field = density, symmfield = tmpdensity)
        density(1:gr%mesh%np) = tmpdensity(1:gr%mesh%np)
      end if

      call symmetrizer_end(symmetrizer)
      SAFE_DEALLOCATE_A(tmpdensity)
    end if

    if(ep%have_density) then
      ! now we solve the poisson equation with the density of all nodes

      SAFE_ALLOCATE(tmp(1:gr%mesh%np_part))
      if(poisson_solver_is_iterative(ep%poisson_solver)) tmp(1:mesh%np) = M_ZERO
      call dpoisson_solve(ep%poisson_solver, tmp, density)
      forall(ip = 1:mesh%np) ep%vpsl(ip) = ep%vpsl(ip) + tmp(ip)
      SAFE_DEALLOCATE_A(tmp)

    end if
    SAFE_DEALLOCATE_A(density)

    ! we assume that we need to recalculate the ion-ion energy
    call ion_interaction_calculate(ep%ion_interaction, geo, sb, ep%eii, ep%fii)

    ! the pseudopotential part.
    do ia = 1, geo%natoms
      atm => geo%atom(ia)
      if(.not. species_is_ps(atm%species)) cycle
      if(.not.simul_box_in_box(sb, geo, geo%atom(ia)%x)) cycle
      call projector_end(ep%proj(ia))
      call projector_init(ep%proj(ia), gr%mesh, atm, st%d%dim)
    end do

    do ia = geo%atoms_dist%start, geo%atoms_dist%end
      if(ep%proj(ia)%type == PROJ_NONE) cycle
      ps => species_ps(geo%atom(ia)%species)
      call submesh_init(ep%proj(ia)%sphere, mesh%sb, mesh, geo%atom(ia)%x, ps%rc_max + mesh%spacing(1))
    end do

    if(geo%atoms_dist%parallel) then
      do ia = 1, geo%natoms
        if(ep%proj(ia)%type == PROJ_NONE) cycle
        ps => species_ps(geo%atom(ia)%species)
        call submesh_broadcast(ep%proj(ia)%sphere, mesh, geo%atom(ia)%x, ps%rc_max + mesh%spacing(1), &
          geo%atoms_dist%node(ia), geo%atoms_dist%mpi_grp)
      end do
    end if
    
    do ia = 1, geo%natoms
      atm => geo%atom(ia)
      call projector_build(ep%proj(ia), gr, atm)
      if(.not. projector_is(ep%proj(ia), PROJ_NONE)) ep%non_local = .true.
    end do

    if (associated(ep%e_field) .and. sb%periodic_dim < sb%dim) ep%vpsl(1:mesh%np) = ep%vpsl(1:mesh%np) + ep%v_static(1:mesh%np)

    POP_SUB(epot_generate)
    call profiling_out(epot_generate_prof)
  end subroutine epot_generate

  ! ---------------------------------------------------------
  logical pure function local_potential_has_density(sb, atom) result(has_density)
    type(simul_box_t),        intent(in)    :: sb
    type(atom_t),             intent(in)    :: atom
    
    has_density = species_has_density(atom%species) .or. (species_is_ps(atom%species) .and. simul_box_is_periodic(sb))
  end function local_potential_has_density
  
  ! ---------------------------------------------------------
  subroutine epot_local_potential(ep, der, dgrid, geo, iatom, vpsl, Imvpsl, rho_core, density, Imdensity)
    type(epot_t),             intent(in)    :: ep
    type(derivatives_t),      intent(in)    :: der
    type(double_grid_t),      intent(in)    :: dgrid
    type(geometry_t),         intent(in)    :: geo
    integer,                  intent(in)    :: iatom
    FLOAT,                    intent(inout) :: vpsl(:)
    FLOAT,          optional, intent(inout) :: Imvpsl(:)
    FLOAT,          optional, pointer       :: rho_core(:)
    FLOAT,          optional, intent(inout) :: density(:) !< If present, the ionic density will be added here.
    FLOAT,          optional, intent(inout) :: Imdensity(:) !< ...and here, for complex scaling

    integer :: ip
    FLOAT :: radius
    FLOAT, allocatable :: vl(:), Imvl(:), rho(:), Imrho(:)
    type(submesh_t)  :: sphere
    type(profile_t), save :: prof

    PUSH_SUB(epot_local_potential)
    call profiling_in(prof, "EPOT_LOCAL")

    !Local potential, we can get it by solving the Poisson equation
    !(for all-electron species or pseudopotentials in periodic
    !systems) or by applying it directly to the grid

    if(local_potential_has_density(der%mesh%sb, geo%atom(iatom))) then
      SAFE_ALLOCATE(rho(1:der%mesh%np))

      call species_get_density(geo%atom(iatom)%species, geo%atom(iatom)%x, der%mesh, rho)

      if(present(density)) then
        forall(ip = 1:der%mesh%np) density(ip) = density(ip) + rho(ip)
      else

        SAFE_ALLOCATE(vl(1:der%mesh%np))

        if(poisson_solver_is_iterative(ep%poisson_solver)) then
          ! vl has to be initialized before entering routine
          ! and our best guess for the potential is zero
          vl(1:der%mesh%np) = M_ZERO
        end if

        call dpoisson_solve(ep%poisson_solver, vl, rho, all_nodes = .false.)
      end if

      SAFE_DEALLOCATE_A(rho)
    else
      SAFE_ALLOCATE(vl(1:der%mesh%np))
      call species_get_local(geo%atom(iatom)%species, der%mesh, geo%atom(iatom)%x(1:der%mesh%sb%dim), vl)
    end if

    if(allocated(vl)) then
      forall(ip = 1:der%mesh%np) vpsl(ip) = vpsl(ip) + vl(ip)
      SAFE_DEALLOCATE_A(vl)
    end if

    !the localized part
    if(species_is_ps(geo%atom(iatom)%species)) then

      radius = double_grid_get_rmax(dgrid, geo%atom(iatom)%species, der%mesh) + der%mesh%spacing(1)

      call submesh_init(sphere, der%mesh%sb, der%mesh, geo%atom(iatom)%x, radius)
      SAFE_ALLOCATE(vl(1:sphere%np))

      call double_grid_apply_local(dgrid, geo%atom(iatom)%species, der%mesh, sphere, geo%atom(iatom)%x, vl)

      ! Cannot be written (correctly) as a vector expression since for periodic systems,
      ! there can be values ip, jp such that sphere%map(ip) == sphere%map(jp).
      do ip = 1, sphere%np
        vpsl(sphere%map(ip)) = vpsl(sphere%map(ip)) + vl(ip)
      end do

      SAFE_DEALLOCATE_A(vl)
      call submesh_end(sphere)
    end if

    !Non-local core corrections
    if(present(rho_core) .and. &
      species_has_nlcc(geo%atom(iatom)%species) .and. &
      species_is_ps(geo%atom(iatom)%species)) then
      SAFE_ALLOCATE(rho(1:der%mesh%np))
      call species_get_nlcc(geo%atom(iatom)%species, geo%atom(iatom)%x, der%mesh, rho)
      forall(ip = 1:der%mesh%np) rho_core(ip) = rho_core(ip) + rho(ip)
      SAFE_DEALLOCATE_A(rho)
    end if

    call profiling_out(prof)
    POP_SUB(epot_local_potential)
  end subroutine epot_local_potential

end module epot_oct_m

!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
